{"name": "一口价购买时地址为空是否购买失败", "status": "failed", "statusDetails": {"message": "AssertionError: assert 400 == 200\n +  where 400 = <Response [400]>.status_code", "trace": "self = <DiaoApp.case.test_httpRun.Test_case object at 0x0000021E73F80B50>\nmodel = <DiaoApp.model.http_model.http_model object at 0x0000021E73EFFE20>\nkwargs = {}, case_num = 18, last_value_list = ['id', 'mainNetName'], i = 1\nvalue = 'mainNetName', data_value = '低傲'\nup_key_list = ['auctionid', 'mainNetName'], up_key = 'mainNetName'\n\n    @allure.title(\"\")  # 断言完成，更新标题\n    @pytest.mark.parametrize(\"model\", models)\n    def test_send_http(self, model, **kwargs):\n        '''\n        :model:传入的数据对象\n        :param kwargs:\n        :return:\n        '''\n        # 记录当前用例顺序\n        case_num = self.models.index(model) + 1\n    \n        allure.step(f\"请求URL: {model.url}\")\n        allure.step(f\"请求方式: {model.method}\")\n        allure.step(f\"请求头: {model.headers}\")\n        allure.step(f\"请求数据: {model.data}\")\n        allure.step(f\"依赖数据: {model.dependence_case}\")\n        allure.step(f\"预期数据: {model.assert_value}\")\n    \n        model.headers = comn().get_headers()\n        if model.is_need:  # 判断是否需要抽取的值\n            if self.contentData:\n                print(self.contentData)\n                # 获取登录token并传入header\n                model.headers = comn().get_headers()\n                model.headers[config['token']] = self.contentData[config['res_code']]\n    \n                # 通过切片获取需要取的值，因为code在第一个所以下标从1往后取\n                last_value_list = model.last_value.split(\",\")[1:]\n                for i in range(len(last_value_list)):\n                    value = last_value_list[i]\n                    data_value = self.contentData[value]\n    \n                    # 修改data中需要更新的字段\n                    # 注：case中update_key中的值必须与对应last_value中code后的值以及顺序一致\n                    if model.update_key is not None:\n                        up_key_list = model.update_key.split(\",\")\n                        up_key = up_key_list[i]\n                        model.data = json.loads(model.data)\n                        model.data[up_key] = str(data_value)\n                        model.data = json.dumps(model.data)\n                # for value in model.last_value.split(\",\")[1:]:\n                #     data_value = self.contentData[value]\n    \n                    # 低傲app  不适用传统header传参方式\n                    # if model.req_params_type == 'data':\n                    #     model.data = eval(model.data)\n                    #     model.data.update({token:data_value})\n                    # elif model.req_params_type == 'json':\n                    #     model.headers = eval(model.headers)\n                    #     model.headers.update({token:data_value})\n                    # elif model.req_params_type == 'params':\n    \n                    #  低傲app，需要根据时间戳生成headers\n                    # if value == config['res_code']:\n                    #     model.headers[config['token']] = data_value  # 更新token到headers\n                    # else:\n                    # 更新data中需要获取的字段\n                    # if model.update_key is not None:\n                    #     for up_key in model.update_key.split(\",\"):\n                    #         model.data = json.loads(model.data)\n                    #         model.data[up_key] = data_value\n                    #         model.data = json.dumps(model.data)\n    \n            else:\n                raise Exception(\"期望全局变量中有数据，但是没有拿到数据\")\n    \n        else:\n            #  低傲app，需要根据时间戳生成headers\n            model.headers = comn().get_headers()\n    \n        ch = coreHttp()\n        time.sleep(2)\n        res = ch.send_http(model.method, model.req_params_type, model.url, model.data, model.headers, **kwargs)\n    \n        if res.status_code == 200:\n            # 抽取要传递给下一个接口的数据\n            if model.extract is not None and model.extract != '':\n                # for ex in eval(model.extract):  # eval把字符串转成列表\n    \n                for ex in model.extract.split(','):  # 通过split把需要传递的元素字符串转换成列表进行遍历\n                    deep_data = Tools().findKey(ex, res.json())\n                    # if deep_data:\n                    #     self.contentData.update({ex: deep_data[0]})\n                    x = random.randint(0, len(deep_data)-1)\n                    print(x)\n                    print(deep_data)\n                    if deep_data:\n                        self.contentData.update({ex: deep_data[x]})\n    \n            # 通过长度断言\n            if model.assert_data.startswith('len'):\n                asserData = [len(jsonpath.jsonpath(res.json(), '$..' + model.assert_data.split('(')[1][:-1])[0])]\n            else:\n                data_assert = jsonpath.jsonpath(res.json(), '$..' + model.assert_data)\n                if str(data_assert) == 'False':  # 处理空值，防止报错\n                    asserData = ['返回数据格式与提取格式不一致，请检查返回数据是否正确！']\n                else:\n                    asserData = jsonpath.jsonpath(res.json(), '$..' + model.assert_data)\n    \n            # 进行断言\n            try:\n                if model.assert_options == \"相等\":\n                    assert asserData[0] == model.assert_value\n                elif model.assert_options == \"包含\":\n                    assert model.assert_value in asserData[0]\n                elif model.assert_options == \"大于\":\n                    assert asserData[0] < model.assert_value\n                elif model.assert_options == \"小于\":\n                    assert asserData[0] > model.assert_value\n                else:\n                    assert asserData[0] != model.assert_value\n    \n                allure.dynamic.title(model.test_title)  # 断言完成，更新allure标题\n    \n                # 断言完成，填写Excel用例中的数据\n                self.write_reslut(model, \"PASS\")\n                kwargs_data = {\n                    \"res\": res,\n                    \"asserData\": asserData,\n                    \"case_num\": case_num,\n                    \"model\": model\n                }\n    \n                self.check_params(**kwargs_data)\n    \n            except Exception as e:\n                allure.dynamic.title(model.test_title)  # 断言完成，更新标题\n                self.write_reslut(model, \"FAILD\")\n                logger.error(e)\n                kwargs_data = {\n                    \"res\": res,\n                    \"asserData\": asserData,\n                    \"case_num\": case_num,\n                    \"model\": model\n                }\n                self.check_params(**kwargs_data)\n                raise e  # 保持异常状态，pytest判定为失败\n    \n        else:\n            asserData = res.json()\n    \n            try:\n                assert res.status_code == 200\n            except Exception as e:\n                allure.dynamic.title(model.test_title)\n                msg = \"Error\\n\" + res.text\n                self.write_reslut(model, msg)\n                logger.error(e)\n                kwargs_data = {\n                    \"res\": res,\n                    \"asserData\": asserData,\n                    \"case_num\": case_num,\n                    \"model\": model\n                }\n                self.check_params(**kwargs_data)\n>               raise e\n\ncase\\test_httpRun.py:193: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DiaoApp.case.test_httpRun.Test_case object at 0x0000021E73F80B50>\nmodel = <DiaoApp.model.http_model.http_model object at 0x0000021E73EFFE20>\nkwargs = {}, case_num = 18, last_value_list = ['id', 'mainNetName'], i = 1\nvalue = 'mainNetName', data_value = '低傲'\nup_key_list = ['auctionid', 'mainNetName'], up_key = 'mainNetName'\n\n    @allure.title(\"\")  # 断言完成，更新标题\n    @pytest.mark.parametrize(\"model\", models)\n    def test_send_http(self, model, **kwargs):\n        '''\n        :model:传入的数据对象\n        :param kwargs:\n        :return:\n        '''\n        # 记录当前用例顺序\n        case_num = self.models.index(model) + 1\n    \n        allure.step(f\"请求URL: {model.url}\")\n        allure.step(f\"请求方式: {model.method}\")\n        allure.step(f\"请求头: {model.headers}\")\n        allure.step(f\"请求数据: {model.data}\")\n        allure.step(f\"依赖数据: {model.dependence_case}\")\n        allure.step(f\"预期数据: {model.assert_value}\")\n    \n        model.headers = comn().get_headers()\n        if model.is_need:  # 判断是否需要抽取的值\n            if self.contentData:\n                print(self.contentData)\n                # 获取登录token并传入header\n                model.headers = comn().get_headers()\n                model.headers[config['token']] = self.contentData[config['res_code']]\n    \n                # 通过切片获取需要取的值，因为code在第一个所以下标从1往后取\n                last_value_list = model.last_value.split(\",\")[1:]\n                for i in range(len(last_value_list)):\n                    value = last_value_list[i]\n                    data_value = self.contentData[value]\n    \n                    # 修改data中需要更新的字段\n                    # 注：case中update_key中的值必须与对应last_value中code后的值以及顺序一致\n                    if model.update_key is not None:\n                        up_key_list = model.update_key.split(\",\")\n                        up_key = up_key_list[i]\n                        model.data = json.loads(model.data)\n                        model.data[up_key] = str(data_value)\n                        model.data = json.dumps(model.data)\n                # for value in model.last_value.split(\",\")[1:]:\n                #     data_value = self.contentData[value]\n    \n                    # 低傲app  不适用传统header传参方式\n                    # if model.req_params_type == 'data':\n                    #     model.data = eval(model.data)\n                    #     model.data.update({token:data_value})\n                    # elif model.req_params_type == 'json':\n                    #     model.headers = eval(model.headers)\n                    #     model.headers.update({token:data_value})\n                    # elif model.req_params_type == 'params':\n    \n                    #  低傲app，需要根据时间戳生成headers\n                    # if value == config['res_code']:\n                    #     model.headers[config['token']] = data_value  # 更新token到headers\n                    # else:\n                    # 更新data中需要获取的字段\n                    # if model.update_key is not None:\n                    #     for up_key in model.update_key.split(\",\"):\n                    #         model.data = json.loads(model.data)\n                    #         model.data[up_key] = data_value\n                    #         model.data = json.dumps(model.data)\n    \n            else:\n                raise Exception(\"期望全局变量中有数据，但是没有拿到数据\")\n    \n        else:\n            #  低傲app，需要根据时间戳生成headers\n            model.headers = comn().get_headers()\n    \n        ch = coreHttp()\n        time.sleep(2)\n        res = ch.send_http(model.method, model.req_params_type, model.url, model.data, model.headers, **kwargs)\n    \n        if res.status_code == 200:\n            # 抽取要传递给下一个接口的数据\n            if model.extract is not None and model.extract != '':\n                # for ex in eval(model.extract):  # eval把字符串转成列表\n    \n                for ex in model.extract.split(','):  # 通过split把需要传递的元素字符串转换成列表进行遍历\n                    deep_data = Tools().findKey(ex, res.json())\n                    # if deep_data:\n                    #     self.contentData.update({ex: deep_data[0]})\n                    x = random.randint(0, len(deep_data)-1)\n                    print(x)\n                    print(deep_data)\n                    if deep_data:\n                        self.contentData.update({ex: deep_data[x]})\n    \n            # 通过长度断言\n            if model.assert_data.startswith('len'):\n                asserData = [len(jsonpath.jsonpath(res.json(), '$..' + model.assert_data.split('(')[1][:-1])[0])]\n            else:\n                data_assert = jsonpath.jsonpath(res.json(), '$..' + model.assert_data)\n                if str(data_assert) == 'False':  # 处理空值，防止报错\n                    asserData = ['返回数据格式与提取格式不一致，请检查返回数据是否正确！']\n                else:\n                    asserData = jsonpath.jsonpath(res.json(), '$..' + model.assert_data)\n    \n            # 进行断言\n            try:\n                if model.assert_options == \"相等\":\n                    assert asserData[0] == model.assert_value\n                elif model.assert_options == \"包含\":\n                    assert model.assert_value in asserData[0]\n                elif model.assert_options == \"大于\":\n                    assert asserData[0] < model.assert_value\n                elif model.assert_options == \"小于\":\n                    assert asserData[0] > model.assert_value\n                else:\n                    assert asserData[0] != model.assert_value\n    \n                allure.dynamic.title(model.test_title)  # 断言完成，更新allure标题\n    \n                # 断言完成，填写Excel用例中的数据\n                self.write_reslut(model, \"PASS\")\n                kwargs_data = {\n                    \"res\": res,\n                    \"asserData\": asserData,\n                    \"case_num\": case_num,\n                    \"model\": model\n                }\n    \n                self.check_params(**kwargs_data)\n    \n            except Exception as e:\n                allure.dynamic.title(model.test_title)  # 断言完成，更新标题\n                self.write_reslut(model, \"FAILD\")\n                logger.error(e)\n                kwargs_data = {\n                    \"res\": res,\n                    \"asserData\": asserData,\n                    \"case_num\": case_num,\n                    \"model\": model\n                }\n                self.check_params(**kwargs_data)\n                raise e  # 保持异常状态，pytest判定为失败\n    \n        else:\n            asserData = res.json()\n    \n            try:\n>               assert res.status_code == 200\nE               assert 400 == 200\nE                +  where 400 = <Response [400]>.status_code\n\ncase\\test_httpRun.py:180: AssertionError"}, "description": "\n        :model:传入的数据对象\n        :param kwargs:\n        :return:\n        ", "attachments": [{"name": "log", "source": "fa9a8a4d-330b-464b-bd8d-7b441cef82ea-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "model", "value": "<DiaoApp.model.http_model.http_model object at 0x0000021E73EFFE20>"}], "start": 1661137952585, "stop": 1661137954673, "uuid": "6001fdd2-2fd7-4404-aeea-34bb56d8b82a", "historyId": "8cd932fcc7ac7ec3b989b979a99fb597", "testCaseId": "ed31b99d3b3aa454dea09452c91e8949", "fullName": "case.test_httpRun.Test_case#test_send_http", "labels": [{"name": "parentSuite", "value": "case"}, {"name": "suite", "value": "test_httpRun"}, {"name": "subSuite", "value": "Test_case"}, {"name": "host", "value": "OS2AQ70MWVFP3P9"}, {"name": "thread", "value": "13404-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "case.test_httpRun"}]}